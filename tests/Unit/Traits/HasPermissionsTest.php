<?php


namespace Kodilab\LaravelBatuta\Tests\Unit\Traits;


use Illuminate\Foundation\Testing\WithFaker;
use Kodilab\LaravelBatuta\Exceptions\ActionNotFound;
use Kodilab\LaravelBatuta\Models\Action;
use Kodilab\LaravelBatuta\Models\Role;
use Kodilab\LaravelBatuta\Testing\Traits\InstallPackage;
use Kodilab\LaravelBatuta\Tests\fixtures\Models\ModelNotImplementsPermissionable;
use Kodilab\LaravelBatuta\Tests\fixtures\Models\User;
use Kodilab\LaravelBatuta\Tests\TestCase;

class HasPermissionsTest extends TestCase
{
    use WithFaker;
    use InstallPackage;

    /** @var User */
    protected $user;

    /** @var Role */
    protected $role;

    /** @var Action */
    protected $action;

    protected function setUp(): void
    {
        parent::setUp(); // TODO: Change the autogenerated stub

        $this->user = factory(User::class)->create();
        $this->action = factory(Action::class)->create();
        $this->role = factory(Role::class)->create();
    }

    public function test_hasPermissions_requires_implementing_Permissionable()
    {
        $this->expectException(\Exception::class);
        new ModelNotImplementsPermissionable();
    }

    /*
     * UPDATE PERMISSION
     */
    public function test_updatePermission_should_update_a_permission()
    {
        $this->user->updatePermission($this->action, false);
        $this->assertFalse($this->user->batuta_actions()->find($this->action->id)->pivot->granted);

        $this->user->updatePermission($this->action, true);
        $this->assertTrue($this->user->batuta_actions()->find($this->action->id)->pivot->granted);
    }

    public function test_updatePermission_should_throw_an_exception_if_the_action_is_not_persisted()
    {
        $this->expectException(ActionNotFound::class);

        $action = factory(Action::class)->make();

        $this->user->updatePermission($action, true);
    }

    public function test_updatePermission_using_the_name_should_update_a_permission()
    {
        $this->user->updatePermission($this->action->name, false);
        $this->assertFalse($this->user->batuta_actions()->find($this->action->id)->pivot->granted);

        $this->user->updatePermission($this->action->name, true);
        $this->assertTrue($this->user->batuta_actions()->find($this->action->id)->pivot->granted);
    }

    public function test_updatePermission_using_the_name_should_throw_an_exception_if_the_name_does_not_exists()
    {
        $this->expectException(ActionNotFound::class);

        $this->user->updatePermission($this->faker->word, false);
    }

    /*
     * BULK PERMISSIONS
     */
    public function test_bulkPermissions_should_update_multiple_permissions()
    {
        $actions = factory(Action::class, 10)->create();

        $permissions = [];

        foreach ($actions as $action) {
            $permissions[$action->id] = $this->faker->boolean;
        }

        $this->user->bulkPermissions($permissions);

        foreach ($permissions as $actionId => $permission) {
            $this->assertEquals($permission, $this->user->batuta_actions()->find($actionId)->pivot->granted);
        }
    }

    public function test_bulkPermissions_should_not_remove_previous_permissions()
    {
        $this->user->updatePermission($this->action, true);

        $actions = factory(Action::class, 10)->create();
        $permissions = [];
        foreach ($actions as $action) {
            $permissions[$action->id] = $this->faker->boolean;
        }
        $this->user->bulkPermissions($permissions);

        $this->assertTrue($this->user->batuta_actions()->find($this->action->id)->pivot->granted);
    }

    public function test_bulkPermissions_with_detaching_mode_should_remove_previous_permissions()
    {
        $this->user->updatePermission($this->action, true);

        $actions = factory(Action::class, 10)->create();
        $permissions = [];
        foreach ($actions as $action) {
            $permissions[$action->id] = $this->faker->boolean;
        }
        $this->user->bulkPermissions($permissions, true);

        $this->assertNull($this->user->batuta_actions()->find($this->action->id));
    }

    /*
     * HAS PERMISSION
     */

    public function test_hasPermission_should_throw_an_exception_if_the_action_does_not_exist()
    {
        $this->expectException(ActionNotFound::class);

        $this->user->hasPermission(factory(Action::class)->make());
    }

    public function test_hasPermission_should_return_whether_the_permission_value_is_if_it_is_set()
    {
        $this->user->updatePermission($this->action, true);
        $this->assertTrue($this->user->hasPermission($this->action));

        $this->user->updatePermission($this->action, false);
        $this->assertFalse($this->user->hasPermission($this->action));
    }

    public function test_hasPermission_should_return_false_if_the_permission_is_not_set()
    {
        $this->user->updatePermission($this->action, false);
        $this->assertFalse($this->user->hasPermission($this->action));
    }

    public function test_hasPermission_should_throw_an_exception_if_the_action_does_not_exist_by_using_the_action_name()
    {
        $this->expectException(ActionNotFound::class);

        $this->user->hasPermission($this->faker->word);
    }

    public function test_hasPermission_should_return_whether_the_permission_is_set_by_using_the_action_name()
    {
        $this->user->updatePermission($this->action, true);
        $this->assertTrue($this->user->hasPermission($this->action->name));

        $this->user->updatePermission($this->action, false);
        $this->assertFalse($this->user->hasPermission($this->action->name));
    }

    public function test_hasPermission_should_return_the_role_inheritance_if_the_permission_is_not_set()
    {
        $this->user->addRole($this->role);

        $this->role->updatePermission($this->action, true);
        $this->assertTrue($this->user->hasPermission($this->action));

        $this->role->updatePermission($this->action, false);
        $this->assertFalse($this->user->hasPermission($this->action));
    }

    public function test_hasPermission_should_return_false_if_the_permission_is_not_set_and_its_role_permissions_is_not_set()
    {
        $this->user->addRole($this->role);

        $this->assertFalse($this->user->hasPermission($this->action));
    }

    public function test_hasPermission_should_return_false_if_the_permission_is_not_set_and_role_inheritance_is_disabled()
    {
        $this->app['config']->set('batuta.role_inheritance', false);

        $this->user->addRole($this->role);
        $this->role->updatePermission($this->action, true);

        $this->assertFalse($this->user->hasPermission($this->action));
    }

    public function test_hasPermission_should_return_the_permission_if_its_set_and_ignore_the_inheritance()
    {
        $this->user->addRole($this->role);

        $this->role->updatePermission($this->action, true);
        $this->user->updatePermission($this->action, false);
        $this->assertFalse($this->user->hasPermission($this->action));

        $this->role->updatePermission($this->action, false);
        $this->user->updatePermission($this->action, true);
        $this->assertTrue($this->user->hasPermission($this->action));
    }

    public function test_hasPermission_should_return_true_if_the_actor_belongs_to_god_role()
    {
        $this->user->addRole(Role::getGod());

        Role::getGod()->updatePermission($this->action, false);

        $this->assertTrue($this->user->hasPermission($this->action));
        $this->assertTrue(Role::getGod()->hasPermission($this->action));
    }

    public function test_hasPermission_should_return_the_permission_if_the_actor_belongs_to_god_role_and_allow_god_is_set_to_false()
    {
        $this->app['config']->set('batuta.allow_god', false);

        $this->user->addRole(Role::getGod());

        Role::getGod()->updatePermission($this->action, false);

        $this->assertFalse($this->user->hasPermission($this->action));
        $this->assertFalse(Role::getGod()->hasPermission($this->action));
    }
}